syntax = "proto3";

package gatewaylnrpc;

/* GatewayLightning is a service that provides limited access and functionality
 * from a lightning node to Fedimint gateways */
service GatewayLightning {
  /* GetPubKey returns the public key of the associated lightning node */
  rpc GetPubKey(EmptyRequest) returns (GetPubKeyResponse) {}

  /* GetRouteHints returns the route hints to the associated lightning node */
  rpc GetRouteHints(EmptyRequest) returns (GetRouteHintsResponse) {}

  /* PayInvoice attempts to pay an invoice using the associated lightning node
   */
  rpc PayInvoice(PayInvoiceRequest) returns (PayInvoiceResponse) {}

  /* SubscribeInterceptHtlcs opens a stream for a client to receive specific
   * HTLCs that have a specific short channel id. For every HTLC intercepted and
   * processed, the client should use `CompleteHtlcs` RPC to stream back a
   * Success or Failure response.
   *
   * Recommendation:
   * GatewayLightning implementations should respond with a channel stream
   * over which intercepted HTLCs are continually sent to the client.
   */
  rpc SubscribeInterceptHtlcs(SubscribeInterceptHtlcsRequest)
      returns (stream SubscribeInterceptHtlcsResponse) {}

  /* CompleteHtlc allows a client to send a Success or Failure response
   * for a HTLC that was intercepted and processed.
   */
  rpc CompleteHtlc(CompleteHtlcsRequest) returns (CompleteHtlcsResponse) {}
}

message EmptyRequest {}

message GetPubKeyResponse {
  // The public key of the associated lightning node
  bytes pub_key = 1;
}

message PayInvoiceRequest {
  string invoice = 1;

  uint64 max_delay = 2;

  double max_fee_percent = 3;
}

message PayInvoiceResponse {
  // The preimage of the invoice
  bytes preimage = 1;
}

// Request to subscribe to HTLCs with a specific short channel id
//
// Send this request when the gateway just assigned a new channel id to a
// newly connected federation. GatewayLightning should respond with a
// stream over which intercepted HTLCs are continually sent to the client.
message SubscribeInterceptHtlcsRequest {
  // The short channel id of HTLCs to intercept
  uint64 short_channel_id = 1;
}

message SubscribeInterceptHtlcsResponse {
  // The HTLC payment hash.
  // Value is not guaranteed to be unique per intercepted HTLC
  bytes payment_hash = 1;

  // The incoming HTLC amount in millisatoshi.
  // This amount minus the `outgoing_amount_msat` is the fee paid for processing
  // this intercepted HTLC
  uint64 incoming_amount_msat = 2;

  // The outgoing HTLC amount in millisatoshi
  // This is the amount we should forward to the Federation if we successfully
  // process this intercepted HTLC
  uint64 outgoing_amount_msat = 3;

  // The incoming HTLC expiry
  // Determines block height when the node will automatically cancel and revert
  // the intercepted HTLC to sender if it is not settled.
  uint32 incoming_expiry = 4;

  // Reserved for getting more details about intercepted HTLC
  reserved 5 to 9;

  // The short channel id of the HTLC.
  // Use this value to confirm relevance of the intercepted HTLC
  uint64 short_channel_id = 10;

  // A unique identifier for every intercepted HTLC
  // Used to identify an intercepted HTLC through processing and settlement
  bytes intercepted_htlc_id = 11;

  // The next onion blob
  bytes next_onion = 12;
}

message CompleteHtlcsRequest {
  message Settle {
    // The preimage for settling an intercepted HTLC
    bytes preimage = 1;
  }

  message Cancel {
    // The reason for the cancellation of an intercepted HTLC
    string reason = 1;
  }

  oneof action {
    // Request to complete an intercepted HTLC with success result after
    // processing
    //
    // Send this request when the gateway successfully processed intercepted
    // HTLC GatewayLightning will settle/resolve the intercepted HTLC with
    // reason provided.
    Settle settle = 1;

    // Request to complete an intercepted HTLC with failure result after
    // processing
    //
    // Send this request when the gateway failed or canceled processing of
    // intercepted HTLC. GatewayLightning will fail/cancel the intercepted HTLC
    // with reason provided.
    Cancel cancel = 2;
  }

  // A unique identifier for every intercepted HTLC
  // Used to identify an intercepted HTLC through processing and settlement
  bytes intercepted_htlc_id = 3;
}

message CompleteHtlcsResponse {}

message GetRouteHintsResponse {
  message RouteHintHop {
    // The node_id of the non-target end of the route.
    bytes src_node_id = 1;

    // The short_channel_id of this channel.
    uint64 short_channel_id = 2;

    // Flat routing fee in millisatoshis.
    uint32 base_msat = 3;

    // Liquidity-based routing fee in millionths of a routed amount.
    // In other words, 10000 is 1%.
    uint32 proportional_millionths = 4;

    // The difference in CLTV values between this node and the next node.
    uint32 cltv_expiry_delta = 5;

    // The minimum value, in msat, which must be relayed to the next hop.
    optional uint64 htlc_minimum_msat = 6;

    // The maximum value in msat available for routing with a single HTLC.
    optional uint64 htlc_maximum_msat = 7;
  }

  message RouteHint {
    // Hops that make up a route hint to the associated lightning node
    repeated RouteHintHop hops = 1;
  }

  // The route hints to the associated lightning node
  repeated RouteHint route_hints = 1;
}
